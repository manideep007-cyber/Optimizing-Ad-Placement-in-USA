# -*- coding: utf-8 -*-
"""dashboard

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1TlrzodmFVM3zHjHkR2nwbBUXoog9U10L
"""

# dashboard.py

import streamlit as st
import pandas as pd
import plotly.express as px

# Load final dataset
@st.cache_data
def load_data():
    return pd.read_csv("final_dashboard_data.csv")

df = load_data()

# Create labeled quartile display for income
quartile_stats = df.groupby("income_quartile")["median_income"].agg(["min", "max"]).astype(int)

quartile_names = {
    "Q1": "Low Income",
    "Q2": "Lower-middle",
    "Q3": "Upper-middle",
    "Q4": "High Income"
}

quartile_labels = {
    q: f"{quartile_names[q]} (${row['min']:,}‚Äì${row['max']:,})"
    for q, row in quartile_stats.iterrows()
}

# Sidebar Filters
st.sidebar.header("Filter Demographics")

# Income quartile with labels
income_quartile = st.sidebar.multiselect(
    "Income Quartile",
    options=list(quartile_labels.keys()),  # ['Q1', 'Q2', ...]
    format_func=lambda x: quartile_labels[x],
    default=None
)

# Age group
age_group = st.sidebar.multiselect(
    "Dominant Age Group", options=sorted(df["dominant_age_group"].unique()), default=None
)

# Race group
race_group = st.sidebar.multiselect(
    "Dominant Race Group", options=sorted(df["dominant_race_group"].unique()), default=None
)

# Top N zones
top_n = st.sidebar.slider("Top N CBGs to View", min_value=5, max_value=50, value=10)

# Scoring weight sliders
st.sidebar.subheader("Scoring Weights")
beta = st.sidebar.slider("Weight for Visit Count (Œ≤)", min_value=0.0, max_value=2.0, value=1.0, step=0.1)
gamma = st.sidebar.slider("Weight for Dwell Time (Œ≥)", min_value=0.0, max_value=2.0, value=1.0, step=0.1)


# Apply filters
filtered_df = df.copy()
if income_quartile:
    filtered_df = filtered_df[filtered_df["income_quartile"].isin(income_quartile)]
if age_group:
    filtered_df = filtered_df[filtered_df["dominant_age_group"].isin(age_group)]
if race_group:
    filtered_df = filtered_df[filtered_df["dominant_race_group"].isin(race_group)]

#  Drop duplicates AFTER filters are applied
filtered_df = filtered_df.sort_values(by='normalized_score', ascending=False).drop_duplicates(subset='GEOID')

# Dynamic scoring based on selected beta and gamma
filtered_df["score"] = (filtered_df["Visit_Count"] ** beta) * (filtered_df["median_dwell"] ** gamma)

# Normalize score to 0‚Äì1 range
min_score = filtered_df["score"].min()
max_score = filtered_df["score"].max()

filtered_df["normalized_score"] = (
    (filtered_df["score"] - min_score) / (max_score - min_score)
    if max_score > min_score else 0
)

# Sort and get top N
top_df = filtered_df.head(top_n)


# Layout
st.title("üìç Optimal Ad Placement Zones in Los Angeles")
st.markdown("Use the filters in the sidebar to explore high-potential zones based on visit activity and demographics.")

# Map
fig = px.scatter_mapbox(
    top_df,
    lat="latitude",
    lon="longitude",
    color="normalized_score",
    hover_name="GEOID",
    hover_data=["Visit_Count", "median_income", "dominant_age_group", "dominant_race_group"],
    zoom=9,
    height=500,
    color_continuous_scale="YlOrRd",
)
fig.update_layout(mapbox_style="carto-darkmatter")
st.plotly_chart(fig, use_container_width=True)

# Table
st.subheader("Summary Table")
st.dataframe(
    top_df[[
        "GEOID",
        "normalized_score",
        "Visit_Count",
        "median_income",
        "dominant_age_group",
        "dominant_race_group",
    ]]
)

